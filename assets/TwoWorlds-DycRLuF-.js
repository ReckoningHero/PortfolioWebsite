import{c as s,i,d as e,p as o,q as n,u as l,s as c,j as r,x as d,b as p,y as m}from"./index-DCFN8E2p.js";const h={class:"container mx-auto lg:px-[5em] px-[9em] mt-[50px] mb-[100px]"},x={class:"max-w-4xl mx-auto font-atyp-display"},u={class:"w-full h-[400px] overflow-hidden rounded-[1.375em] mb-[30px] bg-black"},g=["src"],f={class:"pt-[10px]"},v={__name:"TwoWorlds",setup(b){return(w,t)=>{const a=d("router-link");return p(),s("div",null,[i(o),e("div",h,[e("div",x,[t[1]||(t[1]=e("div",{class:"mb-[30px]"},[e("p",{class:"text-[#CCF303] text-[16px] mb-[8px]"},"Project"),e("h1",{class:"font-semibold lg:text-[3em] text-[36px] text-white mb-[10px]"},"Two Worlds — Technical Breakdown"),e("p",{class:"text-[#6B767F] lg:text-[1.125em] text-[16px]"},"Lead Programmer • Systems Design • Performance & Deployment")],-1)),e("div",u,[e("video",{class:"w-full h-full object-cover object-center",src:l(c),autoplay:"",muted:"",loop:"",playsinline:"",preload:"metadata"}," Your browser does not support the video tag. ",8,g)]),t[2]||(t[2]=n('<section class="lg:text-[1.125em] text-[16px] space-y-[16px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Overview</h2><p> Two Worlds is a third‑person action project developed to explore solid gameplay architecture and performant combat systems. As Lead Programmer, I owned the core gameplay loop end‑to‑end: player control, enemy logic, combat feel, effects integration, and the engineering foundation that made iteration fast and safe. The focus was to build shippable systems—readable, testable, and tuned to run smoothly on console hardware. </p></section><section class="lg:text-[1.125em] text-[16px] space-y-[12px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Role &amp; Responsibilities (Lead Programmer)</h2><ul class="list-disc pl-[20px] space-y-[10px]"><li>Designed and implemented a modular finite‑state machine (FSM) in C++ for player and AI characters.</li><li>Built a combined melee + ranged combat system with aim/lock mechanics, hit detection, and contextual reactions.</li><li>Implemented custom collision checks, traces, and filters to support precise combat and traversal.</li><li>Engineered a projectile system with batching/pooled instances to minimize allocation and improve frame time.</li><li>Authored a two‑pass shader using the stencil buffer for distinctive silhouettes and VFX layering.</li><li>Owned build and deployment pipelines, including UE4 packaging and validation for Xbox One.</li><li>Performance tuning: profiling, reducing draw calls, optimizing tick/update paths, and asset budgets.</li><li>Technical integration: animation notifies, camera tuning, UI hooks, and basic debug/QA tooling.</li><li>Documentation and handoff notes to keep content creators and collaborators unblocked.</li></ul></section><section class="lg:text-[1.125em] text-[16px] space-y-[24px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Core Systems</h2><div class="space-y-[12px]"><h3 class="font-semibold text-white text-[22px]">Finite‑State Machine (C++)</h3><p> I implemented a lightweight FSM to coordinate character intent, transitions, and animation cues. The design favors explicit states (Idle, Move, Dash, MeleeWindup, MeleeSwing, Aim, Fire, Hitstun, Downed) with guarded transitions so edge cases are easy to reason about. State enter/exit callbacks trigger camera tweaks, notifies, and sound cues, while per‑state update functions remain small and testable. </p><ul class="list-disc pl-[20px] space-y-[8px]"><li>Deterministic transitions with clear preconditions and cooldowns.</li><li>Animation‑driven events (via notifies) feed back into the FSM to advance phases safely.</li><li>Shared base utilities for traces, stamina checks, and movement gating keep states lean.</li></ul></div><div class="space-y-[12px]"><h3 class="font-semibold text-white text-[22px]">Melee + Ranged Combat</h3><p> Melee strikes use short‑lived collision windows synced to swing frames; ranged combat uses a hitscan/ballistic hybrid depending on weapon type. Aim assist is conservative—using angular thresholds and target visibility checks— to keep skill expression while ensuring readability. Damage application, stagger, and i‑frames are centralized to avoid duplication across weapon types. </p><ul class="list-disc pl-[20px] space-y-[8px]"><li>Time‑aligned hitboxes toggled by animation notifies to ensure honest hit detection.</li><li>Contextual reactions: light/heavy hitstun and camera recoil for clarity.</li><li>Ranged spread/recoil patterns authored as data assets for quick tuning.</li></ul></div><div class="space-y-[12px]"><h3 class="font-semibold text-white text-[22px]">Custom Collision &amp; Tracing</h3><p> To support precise combat and traversal, I used custom channels and query params for sphere, capsule, and line traces. Sweep tests validate movement in tight spaces, while filtered queries exclude friendly actors or recently hit targets to prevent double‑hits within the same swing. </p></div><div class="space-y-[12px]"><h3 class="font-semibold text-white text-[22px]">Projectile Batching &amp; Pooling</h3><p> Projectiles are pooled and recycled to eliminate frequent allocations. Batched updates run with compact data layouts (position, velocity, lifetime) to keep caches hot and reduce component overhead. Visuals and audio are bound late so logic remains lightweight when many projectiles are active. </p></div><div class="space-y-[12px]"><h3 class="font-semibold text-white text-[22px]">Two‑Pass Shader with Stencil Buffer</h3><p> A custom material effect renders a first pass to mark the stencil, then a second pass for the highlighted silhouette/outline. This provides a readable target highlight and cinematic moments without an expensive full‑screen post process. The effect is authorable via material instances for quick style changes. </p></div></section><section class="lg:text-[1.125em] text-[16px] space-y-[12px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Performance &amp; Deployment</h2><ul class="list-disc pl-[20px] space-y-[10px]"><li>Profiling with Stat Unit, Stat GPU, and Session Frontend to spot CPU/GPU bottlenecks.</li><li>Reduced draw calls by atlasing UI, tightening material variants, and culling small props.</li><li>Eliminated needless ticks by moving logic to timers/events and consolidating update paths.</li><li>Xbox One packaging: handled platform ini settings, texture LODs, and memory budgets.</li><li>Crash repros and log scrubs to fix edge cases before distribution to playtesters.</li></ul></section><section class="lg:text-[1.125em] text-[16px] space-y-[12px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Tools &amp; Workflow</h2><ul class="list-disc pl-[20px] space-y-[10px]"><li>Blueprints for rapid iteration layered over C++ foundations where performance mattered.</li><li>Data assets for combat tuning (damage windows, recoil, stamina costs) with safe defaults.</li><li>Debug overlays for hitboxes, stamina usage, and projectile paths to accelerate balancing.</li><li>Version control with feature branches and small PRs to keep changesets reviewable.</li></ul></section><section class="lg:text-[1.125em] text-[16px] space-y-[12px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Challenges &amp; Solutions</h2><ul class="list-disc pl-[20px] space-y-[10px]"><li> Achieving honest melee hit detection: synchronized animation notifies with buffered collision windows and per‑frame trace validation to avoid “phantom hits”. </li><li> Keeping combat responsive while stable: input buffering and clear state transitions to prevent accidental cancels; cooldowns enforce readability without killing flow. </li><li> Managing many projectiles: pooled instances, batched updates, and culling to keep frame time consistent. </li><li> Readable highlights without heavy post: a cheap stencil‑driven two‑pass effect configured per asset. </li></ul></section><section class="lg:text-[1.125em] text-[16px] space-y-[12px] mb-[40px]"><h2 class="font-semibold lg:text-[2em] text-[28px] text-white mb-[6px]">Lessons Learned</h2><p> Leading Two Worlds reinforced that strong fundamentals—clear state machines, disciplined data flow, and thoughtful performance budgets—make every other part of development easier. Tight integration between code, animation, and camera sells impact more than any single system alone. By investing in tooling and debug visibility early, iteration stays cheap and quality climbs faster. </p></section><div class="bg-[#0B1217] text-[#9AA5AE] p-4 rounded-md mb-[40px]"><p class="text-[14px]"> Media: I can add screenshots/GIFs from the Rookies page next. Share the specific image files or URLs you want, and I’ll import them locally for reliable rendering. </p></div>',8)),e("div",f,[i(a,{to:{path:"/",hash:"#projects"},class:"text-[#CCF303] hover:underline"},{default:r(()=>t[0]||(t[0]=[m("← Back to Projects")])),_:1})])])])])}}};export{v as default};
